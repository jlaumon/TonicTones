//**********************************************************************`
//* This is an include file generated by Message Compiler.             *`
//*                                                                    *`
//* Copyright (c) Microsoft Corporation. All Rights Reserved.          *`
//**********************************************************************`
#pragma once
#include <wmistr.h>
#include <evntrace.h>
#include "evntprov.h"
//
//  Initial Defs
//
#if !defined(ETW_INLINE)
#define ETW_INLINE DECLSPEC_NOINLINE __inline
#endif

#if defined(__cplusplus)
extern "C" {
#endif

//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION
#if  !defined(McGenDebug)
#define McGenDebug(a,b)
#endif 


#if !defined(MCGEN_TRACE_CONTEXT_DEF)
#define MCGEN_TRACE_CONTEXT_DEF
typedef struct _MCGEN_TRACE_CONTEXT
{
    TRACEHANDLE     RegistrationHandle;
    TRACEHANDLE     Logger;
    ULONGLONG       MatchAnyKeyword;
    ULONGLONG       MatchAllKeyword;
    ULONG           Flags;
    ULONG           IsEnabled;
    UCHAR           Level; 
    UCHAR           Reserve;
} MCGEN_TRACE_CONTEXT, *PMCGEN_TRACE_CONTEXT;
#endif

#if !defined(MCGEN_EVENT_ENABLED_DEF)
#define MCGEN_EVENT_ENABLED_DEF
FORCEINLINE
BOOLEAN
McGenEventEnabled(
    __in PMCGEN_TRACE_CONTEXT EnableInfo,
    __in PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    //
    // Check if the event Level is lower than the level at which
    // the channel is enabled.
    // If the event Level is 0 or the channel is enabled at level 0,
    // all levels are enabled.
    //

    if ((EventDescriptor->Level <= EnableInfo->Level) || // This also covers the case of Level == 0.
        (EnableInfo->Level == 0)) {

        //
        // Check if Keyword is enabled
        //

        if ((EventDescriptor->Keyword == (ULONGLONG)0) ||
            ((EventDescriptor->Keyword & EnableInfo->MatchAnyKeyword) &&
             ((EventDescriptor->Keyword & EnableInfo->MatchAllKeyword) == EnableInfo->MatchAllKeyword))) {
            return TRUE;
        }
    }

    return FALSE;

}
#endif


//
// EnableCheckMacro
//
#ifndef MCGEN_ENABLE_CHECK
#define MCGEN_ENABLE_CHECK(Context, Descriptor) (Context.IsEnabled &&  McGenEventEnabled(&Context, &Descriptor))
#endif

#if !defined(MCGEN_CONTROL_CALLBACK)
#define MCGEN_CONTROL_CALLBACK

DECLSPEC_NOINLINE __inline
VOID
__stdcall
McGenControlCallbackV2(
    __in LPCGUID SourceId,
    __in ULONG ControlCode,
    __in UCHAR Level,
    __in ULONGLONG MatchAnyKeyword,
    __in ULONGLONG MatchAllKeyword,
    __in_opt PEVENT_FILTER_DESCRIPTOR FilterData,
    __inout_opt PVOID CallbackContext
    )
/*++

Routine Description:

    This is the notification callback for Vista.

Arguments:

    SourceId - The GUID that identifies the session that enabled the provider. 

    ControlCode - The parameter indicates whether the provider 
                  is being enabled or disabled.

    Level - The level at which the event is enabled.

    MatchAnyKeyword - The bitmask of keywords that the provider uses to 
                      determine the category of events that it writes.

    MatchAllKeyword - This bitmask additionally restricts the category 
                      of events that the provider writes. 

    FilterData - The provider-defined data.

    CallbackContext - The context of the callback that is defined when the provider 
                      called EtwRegister to register itself.

Remarks:

    ETW calls this function to notify provider of enable/disable

--*/
{
    PMCGEN_TRACE_CONTEXT Ctx = (PMCGEN_TRACE_CONTEXT)CallbackContext;
#ifndef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(FilterData);
#endif

    if (Ctx == NULL) {
        return;
    }

    switch (ControlCode) {

        case EVENT_CONTROL_CODE_ENABLE_PROVIDER:
            Ctx->Level = Level;
            Ctx->MatchAnyKeyword = MatchAnyKeyword;
            Ctx->MatchAllKeyword = MatchAllKeyword;
            Ctx->IsEnabled = EVENT_CONTROL_CODE_ENABLE_PROVIDER;
            break;

        case EVENT_CONTROL_CODE_DISABLE_PROVIDER:
            Ctx->IsEnabled = EVENT_CONTROL_CODE_DISABLE_PROVIDER;
            Ctx->Level = 0;
            Ctx->MatchAnyKeyword = 0;
            Ctx->MatchAllKeyword = 0;
            break;
 
        default:
            break;
    }

#ifdef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    //
    // Call user defined callback
    //
    MCGEN_PRIVATE_ENABLE_CALLBACK_V2(
        SourceId,
        ControlCode,
        Level,
        MatchAnyKeyword,
        MatchAllKeyword,
        FilterData,
        CallbackContext
        );
#endif
   
    return;
}

#endif
#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION
//+
// Provider Multi-Main Event Count 4
//+
EXTERN_C __declspec(selectany) const GUID MULTI_MAIN = {0x231cf54b, 0x22a0, 0x49e4, {0xa5, 0x9a, 0x47, 0x05, 0x2a, 0x30, 0xff, 0xed}};

//
// Opcodes
//
#define _BeginOpcode 0xa
#define _EndOpcode 0xb
#define _StepOpcode 0xc
#define _MarkOpcode 0xd
#define _InformationOpcode 0xe

//
// Tasks
//
#define Block_Task 0x1
EXTERN_C __declspec(selectany) const GUID BlockId = {0x4e9a75eb, 0x4fba, 0x4ba0, {0x9a, 0x1b, 0x21, 0x75, 0xb6, 0x71, 0xa1, 0x6d}};
#define ThreadID_Task 0x2
EXTERN_C __declspec(selectany) const GUID ThreadIDId = {0xf2ec684f, 0xad3a, 0x4af5, {0x8b, 0x10, 0xe7, 0xb2, 0x9a, 0xf6, 0x7e, 0xe2}};
//
// Keyword
//
#define MULTI_MAIN_KEYWORD_HighFrequency 0x2
#define MULTI_MAIN_KEYWORD_NormalFrequency 0x1

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Start = {0x64, 0x0, 0x0, 0x0, 0xa, 0x1, 0x1};
#define Start_value 0x64
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Stop = {0x65, 0x0, 0x0, 0x0, 0xb, 0x1, 0x1};
#define Stop_value 0x65
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mark = {0x66, 0x0, 0x0, 0x0, 0xd, 0x1, 0x1};
#define Mark_value 0x66
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Thread_ID = {0x67, 0x0, 0x0, 0x0, 0xe, 0x2, 0x1};
#define Thread_ID_value 0x67

//
// Note on Generate Code from Manifest Windows Vista and above
//
//Structures :  are handled as a size and pointer pairs. The macro for the event will have an extra 
//parameter for the size in bytes of the structure. Make sure that your structures have no extra padding.
//
//Strings: There are several cases that can be described in the manifest. For array of variable length 
//strings, the generated code will take the count of characters for the whole array as an input parameter. 
//
//SID No support for array of SIDs, the macro will take a pointer to the SID and use appropriate 
//GetLengthSid function to get the length.
//

//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Globals 
//

EXTERN_C __declspec(selectany) REGHANDLE Multi_MainHandle = (REGHANDLE)0;

EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MULTI_MAIN_Context = {0};

#if !defined(McGenEventRegisterUnregister)
#define McGenEventRegisterUnregister
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventRegister(
    __in LPCGUID ProviderId,
    __in_opt PENABLECALLBACK EnableCallback,
    __in_opt PVOID CallbackContext,
    __inout PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function register the provider with ETW USER mode.

Arguments:
    ProviderId - Provider Id to be register with ETW.

    EnableCallback - Callback to be used.

    CallbackContext - Context for this provider.

    RegHandle - Pointer to Registration handle.

Remarks:

    If the handle != NULL will return ERROR_SUCCESS

--*/
{
    ULONG Error;


    if (*RegHandle) {
        //
        // already registered
        //
        return ERROR_SUCCESS;
    }

    Error = EventRegister( ProviderId, EnableCallback, CallbackContext, RegHandle); 

    return Error;
}


DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventUnregister(__inout PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW USER mode

Arguments:
            RegHandle this is the pointer to the provider context
Remarks:
            If Provider has not register RegHandle = NULL,
            return ERROR_SUCCESS
--*/
{
    ULONG Error;


    if(!(*RegHandle)) {
        //
        // Provider has not registerd
        //
        return ERROR_SUCCESS;
    }

    Error = EventUnregister(*RegHandle); 
    *RegHandle = (REGHANDLE)0;
    
    return Error;
}
#endif
//
// Register with ETW Vista +
//
#ifndef EventRegisterMulti_Main
#define EventRegisterMulti_Main() McGenEventRegister(&MULTI_MAIN, McGenControlCallbackV2, &MULTI_MAIN_Context, &Multi_MainHandle) 
#endif

//
// UnRegister with ETW
//
#ifndef EventUnregisterMulti_Main
#define EventUnregisterMulti_Main() McGenEventUnregister(&Multi_MainHandle) 
#endif

//
// Event Macro for Start
//
#define EventWriteStart(Description, Depth)\
        MCGEN_ENABLE_CHECK(MULTI_MAIN_Context, Start) ?\
        Template_sd(Multi_MainHandle, &Start, Description, Depth)\
        : ERROR_SUCCESS\

//
// Event Macro for Stop
//
#define EventWriteStop(Description, Depth, Duration__ms_)\
        MCGEN_ENABLE_CHECK(MULTI_MAIN_Context, Stop) ?\
        Template_sdf(Multi_MainHandle, &Stop, Description, Depth, Duration__ms_)\
        : ERROR_SUCCESS\

//
// Event Macro for Mark
//
#define EventWriteMark(Description)\
        MCGEN_ENABLE_CHECK(MULTI_MAIN_Context, Mark) ?\
        Template_s(Multi_MainHandle, &Mark, Description)\
        : ERROR_SUCCESS\

//
// Event Macro for Thread_ID
//
#define EventWriteThread_ID(ThreadID, ThreadName)\
        MCGEN_ENABLE_CHECK(MULTI_MAIN_Context, Thread_ID) ?\
        Template_ds(Multi_MainHandle, &Thread_ID, ThreadID, ThreadName)\
        : ERROR_SUCCESS\

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+
// Provider Multi-Worker Event Count 3
//+
EXTERN_C __declspec(selectany) const GUID MULTI_WORKER = {0xe9c3da11, 0xe2a5, 0x48fd, {0x9c, 0xd3, 0x17, 0xe7, 0xc7, 0x64, 0xd3, 0x03}};

//
// Opcodes
//
#define _BeginOpcode 0xa
#define _EndOpcode 0xb
#define _StepOpcode 0xc
#define _MarkOpcode 0xd

//
// Tasks
//
#define Block_Task 0x1
EXTERN_C __declspec(selectany) const GUID BlockWorkerId = {0x9e4a04f0, 0xc229, 0x4a16, {0x94, 0x54, 0xd1, 0x2a, 0x5b, 0xa2, 0x41, 0x84}};
//
// Keyword
//
#define MULTI_WORKER_KEYWORD_HighFrequency 0x2
#define MULTI_WORKER_KEYWORD_NormalFrequency 0x1

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StartWorker = {0x64, 0x0, 0x0, 0x0, 0xa, 0x1, 0x0};
#define StartWorker_value 0x64
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR StopWorker = {0x65, 0x0, 0x0, 0x0, 0xb, 0x1, 0x0};
#define StopWorker_value 0x65
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR MarkWorker = {0x66, 0x0, 0x0, 0x0, 0xd, 0x1, 0x0};
#define MarkWorker_value 0x66

//
// Note on Generate Code from Manifest Windows Vista and above
//
//Structures :  are handled as a size and pointer pairs. The macro for the event will have an extra 
//parameter for the size in bytes of the structure. Make sure that your structures have no extra padding.
//
//Strings: There are several cases that can be described in the manifest. For array of variable length 
//strings, the generated code will take the count of characters for the whole array as an input parameter. 
//
//SID No support for array of SIDs, the macro will take a pointer to the SID and use appropriate 
//GetLengthSid function to get the length.
//

//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Globals 
//

EXTERN_C __declspec(selectany) REGHANDLE Multi_WorkerHandle = (REGHANDLE)0;

EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MULTI_WORKER_Context = {0};

#if !defined(McGenEventRegisterUnregister)
#define McGenEventRegisterUnregister
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventRegister(
    __in LPCGUID ProviderId,
    __in_opt PENABLECALLBACK EnableCallback,
    __in_opt PVOID CallbackContext,
    __inout PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function register the provider with ETW USER mode.

Arguments:
    ProviderId - Provider Id to be register with ETW.

    EnableCallback - Callback to be used.

    CallbackContext - Context for this provider.

    RegHandle - Pointer to Registration handle.

Remarks:

    If the handle != NULL will return ERROR_SUCCESS

--*/
{
    ULONG Error;


    if (*RegHandle) {
        //
        // already registered
        //
        return ERROR_SUCCESS;
    }

    Error = EventRegister( ProviderId, EnableCallback, CallbackContext, RegHandle); 

    return Error;
}


DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventUnregister(__inout PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW USER mode

Arguments:
            RegHandle this is the pointer to the provider context
Remarks:
            If Provider has not register RegHandle = NULL,
            return ERROR_SUCCESS
--*/
{
    ULONG Error;


    if(!(*RegHandle)) {
        //
        // Provider has not registerd
        //
        return ERROR_SUCCESS;
    }

    Error = EventUnregister(*RegHandle); 
    *RegHandle = (REGHANDLE)0;
    
    return Error;
}
#endif
//
// Register with ETW Vista +
//
#ifndef EventRegisterMulti_Worker
#define EventRegisterMulti_Worker() McGenEventRegister(&MULTI_WORKER, McGenControlCallbackV2, &MULTI_WORKER_Context, &Multi_WorkerHandle) 
#endif

//
// UnRegister with ETW
//
#ifndef EventUnregisterMulti_Worker
#define EventUnregisterMulti_Worker() McGenEventUnregister(&Multi_WorkerHandle) 
#endif

//
// Event Macro for StartWorker
//
#define EventWriteStartWorker(Description, Depth)\
        MCGEN_ENABLE_CHECK(MULTI_WORKER_Context, StartWorker) ?\
        Template_sd(Multi_WorkerHandle, &StartWorker, Description, Depth)\
        : ERROR_SUCCESS\

//
// Event Macro for StopWorker
//
#define EventWriteStopWorker(Description, Depth, Duration__ms_)\
        MCGEN_ENABLE_CHECK(MULTI_WORKER_Context, StopWorker) ?\
        Template_sdf(Multi_WorkerHandle, &StopWorker, Description, Depth, Duration__ms_)\
        : ERROR_SUCCESS\

//
// Event Macro for MarkWorker
//
#define EventWriteMarkWorker(Description)\
        MCGEN_ENABLE_CHECK(MULTI_WORKER_Context, MarkWorker) ?\
        Template_s(Multi_WorkerHandle, &MarkWorker, Description)\
        : ERROR_SUCCESS\

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+
// Provider Multi-FrameRate Event Count 1
//+
EXTERN_C __declspec(selectany) const GUID MULTI_FRAMERATE = {0x2b25961d, 0xba6e, 0x4d79, {0xbe, 0xc7, 0x36, 0x05, 0x36, 0x6e, 0x2e, 0x09}};

//
// Opcodes
//
#define _RenderFrameMarkOpcode 0xa

//
// Tasks
//
#define Frame_Task 0x1
EXTERN_C __declspec(selectany) const GUID FrameId = {0x43dada85, 0x49b6, 0x4438, {0x83, 0xd6, 0x93, 0x14, 0x77, 0x63, 0x5d, 0xe3}};
//
// Keyword
//
#define MULTI_FRAMERATE_KEYWORD_HighFrequency 0x2
#define MULTI_FRAMERATE_KEYWORD_NormalFrequency 0x1

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RenderFrameMark = {0xc8, 0x0, 0x0, 0x0, 0xa, 0x1, 0x1};
#define RenderFrameMark_value 0xc8

//
// Note on Generate Code from Manifest Windows Vista and above
//
//Structures :  are handled as a size and pointer pairs. The macro for the event will have an extra 
//parameter for the size in bytes of the structure. Make sure that your structures have no extra padding.
//
//Strings: There are several cases that can be described in the manifest. For array of variable length 
//strings, the generated code will take the count of characters for the whole array as an input parameter. 
//
//SID No support for array of SIDs, the macro will take a pointer to the SID and use appropriate 
//GetLengthSid function to get the length.
//

//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Globals 
//

EXTERN_C __declspec(selectany) REGHANDLE Multi_FrameRateHandle = (REGHANDLE)0;

EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MULTI_FRAMERATE_Context = {0};

#if !defined(McGenEventRegisterUnregister)
#define McGenEventRegisterUnregister
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventRegister(
    __in LPCGUID ProviderId,
    __in_opt PENABLECALLBACK EnableCallback,
    __in_opt PVOID CallbackContext,
    __inout PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function register the provider with ETW USER mode.

Arguments:
    ProviderId - Provider Id to be register with ETW.

    EnableCallback - Callback to be used.

    CallbackContext - Context for this provider.

    RegHandle - Pointer to Registration handle.

Remarks:

    If the handle != NULL will return ERROR_SUCCESS

--*/
{
    ULONG Error;


    if (*RegHandle) {
        //
        // already registered
        //
        return ERROR_SUCCESS;
    }

    Error = EventRegister( ProviderId, EnableCallback, CallbackContext, RegHandle); 

    return Error;
}


DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventUnregister(__inout PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW USER mode

Arguments:
            RegHandle this is the pointer to the provider context
Remarks:
            If Provider has not register RegHandle = NULL,
            return ERROR_SUCCESS
--*/
{
    ULONG Error;


    if(!(*RegHandle)) {
        //
        // Provider has not registerd
        //
        return ERROR_SUCCESS;
    }

    Error = EventUnregister(*RegHandle); 
    *RegHandle = (REGHANDLE)0;
    
    return Error;
}
#endif
//
// Register with ETW Vista +
//
#ifndef EventRegisterMulti_FrameRate
#define EventRegisterMulti_FrameRate() McGenEventRegister(&MULTI_FRAMERATE, McGenControlCallbackV2, &MULTI_FRAMERATE_Context, &Multi_FrameRateHandle) 
#endif

//
// UnRegister with ETW
//
#ifndef EventUnregisterMulti_FrameRate
#define EventUnregisterMulti_FrameRate() McGenEventUnregister(&Multi_FrameRateHandle) 
#endif

//
// Event Macro for RenderFrameMark
//
#define EventWriteRenderFrameMark(Frame_number, Duration__ms_)\
        MCGEN_ENABLE_CHECK(MULTI_FRAMERATE_Context, RenderFrameMark) ?\
        Template_df(Multi_FrameRateHandle, &RenderFrameMark, Frame_number, Duration__ms_)\
        : ERROR_SUCCESS\

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+
// Provider Multi-Input Event Count 5
//+
EXTERN_C __declspec(selectany) const GUID MULTI_INPUT = {0x70e2503b, 0xc6f3, 0x4780, {0xb3, 0x23, 0xbd, 0x8e, 0xd0, 0xc6, 0x1b, 0xf8}};

//
// Opcodes
//
#define _MouseDownOpcode 0xa
#define _MouseUpOpcode 0xb
#define _MouseMoveOpcode 0xc
#define _MouseWheelOpcode 0xd
#define _KeyDownOpcode 0xe

//
// Tasks
//
#define Mouse_Task 0x1
EXTERN_C __declspec(selectany) const GUID MouseId = {0x8317ff5b, 0x2854, 0x4ff4, {0xaf, 0x5f, 0xf4, 0xa1, 0x23, 0xb5, 0x14, 0xae}};
#define Keyboard_Task 0x2
EXTERN_C __declspec(selectany) const GUID KeyboardId = {0x8a86f981, 0xc58b, 0x4940, {0x85, 0xe0, 0xc0, 0x3b, 0x61, 0x2f, 0xfb, 0xe8}};
//
// Keyword
//
#define MULTI_INPUT_KEYWORD_HighFrequency 0x2
#define MULTI_INPUT_KEYWORD_NormalFrequency 0x1

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mouse_down = {0x190, 0x0, 0x0, 0x0, 0xa, 0x1, 0x1};
#define Mouse_down_value 0x190
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mouse_up = {0x191, 0x0, 0x0, 0x0, 0xb, 0x1, 0x1};
#define Mouse_up_value 0x191
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mouse_move = {0x192, 0x0, 0x0, 0x0, 0xc, 0x1, 0x2};
#define Mouse_move_value 0x192
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Mouse_wheel = {0x193, 0x0, 0x0, 0x0, 0xd, 0x1, 0x1};
#define Mouse_wheel_value 0x193
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR Key_down = {0x194, 0x0, 0x0, 0x0, 0xe, 0x2, 0x1};
#define Key_down_value 0x194

//
// Note on Generate Code from Manifest Windows Vista and above
//
//Structures :  are handled as a size and pointer pairs. The macro for the event will have an extra 
//parameter for the size in bytes of the structure. Make sure that your structures have no extra padding.
//
//Strings: There are several cases that can be described in the manifest. For array of variable length 
//strings, the generated code will take the count of characters for the whole array as an input parameter. 
//
//SID No support for array of SIDs, the macro will take a pointer to the SID and use appropriate 
//GetLengthSid function to get the length.
//

//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Globals 
//

EXTERN_C __declspec(selectany) REGHANDLE Multi_InputHandle = (REGHANDLE)0;

EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT MULTI_INPUT_Context = {0};

#if !defined(McGenEventRegisterUnregister)
#define McGenEventRegisterUnregister
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventRegister(
    __in LPCGUID ProviderId,
    __in_opt PENABLECALLBACK EnableCallback,
    __in_opt PVOID CallbackContext,
    __inout PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function register the provider with ETW USER mode.

Arguments:
    ProviderId - Provider Id to be register with ETW.

    EnableCallback - Callback to be used.

    CallbackContext - Context for this provider.

    RegHandle - Pointer to Registration handle.

Remarks:

    If the handle != NULL will return ERROR_SUCCESS

--*/
{
    ULONG Error;


    if (*RegHandle) {
        //
        // already registered
        //
        return ERROR_SUCCESS;
    }

    Error = EventRegister( ProviderId, EnableCallback, CallbackContext, RegHandle); 

    return Error;
}


DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventUnregister(__inout PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW USER mode

Arguments:
            RegHandle this is the pointer to the provider context
Remarks:
            If Provider has not register RegHandle = NULL,
            return ERROR_SUCCESS
--*/
{
    ULONG Error;


    if(!(*RegHandle)) {
        //
        // Provider has not registerd
        //
        return ERROR_SUCCESS;
    }

    Error = EventUnregister(*RegHandle); 
    *RegHandle = (REGHANDLE)0;
    
    return Error;
}
#endif
//
// Register with ETW Vista +
//
#ifndef EventRegisterMulti_Input
#define EventRegisterMulti_Input() McGenEventRegister(&MULTI_INPUT, McGenControlCallbackV2, &MULTI_INPUT_Context, &Multi_InputHandle) 
#endif

//
// UnRegister with ETW
//
#ifndef EventUnregisterMulti_Input
#define EventUnregisterMulti_Input() McGenEventUnregister(&Multi_InputHandle) 
#endif

//
// Event Macro for Mouse_down
//
#define EventWriteMouse_down(Button_Type, Flags, x, y)\
        MCGEN_ENABLE_CHECK(MULTI_INPUT_Context, Mouse_down) ?\
        Template_dqdd(Multi_InputHandle, &Mouse_down, Button_Type, Flags, x, y)\
        : ERROR_SUCCESS\

//
// Event Macro for Mouse_up
//
#define EventWriteMouse_up(Button_Type, Flags, x, y)\
        MCGEN_ENABLE_CHECK(MULTI_INPUT_Context, Mouse_up) ?\
        Template_dqdd(Multi_InputHandle, &Mouse_up, Button_Type, Flags, x, y)\
        : ERROR_SUCCESS\

//
// Event Macro for Mouse_move
//
#define EventWriteMouse_move(Flags, x, y)\
        MCGEN_ENABLE_CHECK(MULTI_INPUT_Context, Mouse_move) ?\
        Template_qdd(Multi_InputHandle, &Mouse_move, Flags, x, y)\
        : ERROR_SUCCESS\

//
// Event Macro for Mouse_wheel
//
#define EventWriteMouse_wheel(Flags, zDelta, x, y)\
        MCGEN_ENABLE_CHECK(MULTI_INPUT_Context, Mouse_wheel) ?\
        Template_qddd(Multi_InputHandle, &Mouse_wheel, Flags, zDelta, x, y)\
        : ERROR_SUCCESS\

//
// Event Macro for Key_down
//
#define EventWriteKey_down(Virtual_key_code, Repeat_count, Flags)\
        MCGEN_ENABLE_CHECK(MULTI_INPUT_Context, Key_down) ?\
        Template_qqq(Multi_InputHandle, &Key_down, Virtual_key_code, Repeat_count, Flags)\
        : ERROR_SUCCESS\

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION


//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Template Functions 
//
//
//Template from manifest : T_Start
//
#ifndef Template_sd_def
#define Template_sd_def
ETW_INLINE
ULONG
Template_sd(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in_opt LPCSTR  Description,
    __in const signed int  Depth
    )
{
#define ARGUMENT_COUNT_sd 2

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_sd];

    EventDataDescCreate(&EventData[0], 
                        (Description != NULL) ? Description : "NULL",
                        (Description != NULL) ? (ULONG)((strlen(Description) + 1) * sizeof(CHAR)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[1], &Depth, sizeof(const signed int)  );

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_sd, EventData);
}
#endif

//
//Template from manifest : T_End
//
#ifndef Template_sdf_def
#define Template_sdf_def
ETW_INLINE
ULONG
Template_sdf(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in_opt LPCSTR  Description,
    __in const signed int  Depth,
    __in const float  Duration__ms_
    )
{
#define ARGUMENT_COUNT_sdf 3

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_sdf];

    EventDataDescCreate(&EventData[0], 
                        (Description != NULL) ? Description : "NULL",
                        (Description != NULL) ? (ULONG)((strlen(Description) + 1) * sizeof(CHAR)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[1], &Depth, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[2], &Duration__ms_, sizeof(const float)  );

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_sdf, EventData);
}
#endif

//
//Template from manifest : T_Mark
//
#ifndef Template_s_def
#define Template_s_def
ETW_INLINE
ULONG
Template_s(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in_opt LPCSTR  Description
    )
{
#define ARGUMENT_COUNT_s 1

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_s];

    EventDataDescCreate(&EventData[0], 
                        (Description != NULL) ? Description : "NULL",
                        (Description != NULL) ? (ULONG)((strlen(Description) + 1) * sizeof(CHAR)) : (ULONG)sizeof("NULL"));

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_s, EventData);
}
#endif

//
//Template from manifest : T_ThreadID
//
#ifndef Template_ds_def
#define Template_ds_def
ETW_INLINE
ULONG
Template_ds(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in const signed int  ThreadID,
    __in_opt LPCSTR  ThreadName
    )
{
#define ARGUMENT_COUNT_ds 2

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_ds];

    EventDataDescCreate(&EventData[0], &ThreadID, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[1], 
                        (ThreadName != NULL) ? ThreadName : "NULL",
                        (ThreadName != NULL) ? (ULONG)((strlen(ThreadName) + 1) * sizeof(CHAR)) : (ULONG)sizeof("NULL"));

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_ds, EventData);
}
#endif

//
//Template from manifest : T_FrameMark
//
#ifndef Template_df_def
#define Template_df_def
ETW_INLINE
ULONG
Template_df(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in const signed int  Frame_number,
    __in const float  Duration__ms_
    )
{
#define ARGUMENT_COUNT_df 2

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_df];

    EventDataDescCreate(&EventData[0], &Frame_number, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[1], &Duration__ms_, sizeof(const float)  );

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_df, EventData);
}
#endif

//
//Template from manifest : T_MouseClick
//
#ifndef Template_dqdd_def
#define Template_dqdd_def
ETW_INLINE
ULONG
Template_dqdd(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in const signed int  Button_Type,
    __in const unsigned int  Flags,
    __in const signed int  x,
    __in const signed int  y
    )
{
#define ARGUMENT_COUNT_dqdd 4

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_dqdd];

    EventDataDescCreate(&EventData[0], &Button_Type, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[1], &Flags, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2], &x, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3], &y, sizeof(const signed int)  );

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_dqdd, EventData);
}
#endif

//
//Template from manifest : T_MouseMove
//
#ifndef Template_qdd_def
#define Template_qdd_def
ETW_INLINE
ULONG
Template_qdd(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in const unsigned int  Flags,
    __in const signed int  x,
    __in const signed int  y
    )
{
#define ARGUMENT_COUNT_qdd 3

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_qdd];

    EventDataDescCreate(&EventData[0], &Flags, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[1], &x, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[2], &y, sizeof(const signed int)  );

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_qdd, EventData);
}
#endif

//
//Template from manifest : T_MouseWheel
//
#ifndef Template_qddd_def
#define Template_qddd_def
ETW_INLINE
ULONG
Template_qddd(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in const unsigned int  Flags,
    __in const signed int  zDelta,
    __in const signed int  x,
    __in const signed int  y
    )
{
#define ARGUMENT_COUNT_qddd 4

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_qddd];

    EventDataDescCreate(&EventData[0], &Flags, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[1], &zDelta, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[2], &x, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3], &y, sizeof(const signed int)  );

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_qddd, EventData);
}
#endif

//
//Template from manifest : T_KeyPress
//
#ifndef Template_qqq_def
#define Template_qqq_def
ETW_INLINE
ULONG
Template_qqq(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in const unsigned int  Virtual_key_code,
    __in const unsigned int  Repeat_count,
    __in const unsigned int  Flags
    )
{
#define ARGUMENT_COUNT_qqq 3

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_qqq];

    EventDataDescCreate(&EventData[0], &Virtual_key_code, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[1], &Repeat_count, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2], &Flags, sizeof(const unsigned int)  );

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_qqq, EventData);
}
#endif

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

#if defined(__cplusplus)
};
#endif

